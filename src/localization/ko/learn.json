{
  "examples.starter.title": "실습",
  "examples.starter.description": "이제 배운 내용을 시도하는 연습을 해볼 차례입니다",

  "examples.finish.title": "실습 완료!",
  "examples.finish.description": " ",

  "steps.starter.title": "개요",
  "steps.starter.description": "RegEx는 `Regular Expression`의 줄임말입니다. 이것은 내용을 찾거나 관리하는 데 도움이 됩니다. RegEx 필드에 'OK'를 입력하여 첫 번째 단계를 진행하고 자세한 설명에 접근합니다...",

  "steps.whatIsRegex.title": "Regular Expressions, `RegEx`는 무슨 뜻일까?",
  "steps.whatIsRegex.description": "Regular Expressions 검색패턴을 표현하는 문자열입니다. 자주 `RegEx` 혹은 `RegExp`로 불립니다. 이것은 내용의 단어를 찾거나 대체하는데 용이합니다. 추가적으로, 내용이 우리가 설정한 규칙에 부합하는지 확인할 수 있습니다.\\n\\n 예를 들어, 파일이름들이 있다고 가정해봅시다. 이때 'pdf'형식의 파일만 찾고싶을때, 이 `^\\w+\\.pdf$` 표현을 입력하면 찾을 수 있을 것 입니다. 진행 단계가 거듭될수록 표현의 정의의 의미는 더 정확해질 것입니다.",

  "steps.basicMatchers.title": "기본 매칭",
  "steps.basicMatchers.description": "우리가 찾고자 하는 단어 내용을 직접 작성합니다. 이는 기본 검색 과정과 동일합니다. 예를 들어, 문단에 'curious'이라는 단어를 찾기 위해서 똑같이 작성하면 됩니다.",

  "steps.dotCharacter.title": "점 `.`: 아무 문자",
  "steps.dotCharacter.description": "이 `.`기호는 특수문자나 여백을 포함한 아무 문자를 구분합니다.",

  "steps.characterSet.title": "문자열 `[abc]`",
  "steps.characterSet.description": "한단어가 여러 문자열인 경우, 우리는 이를 모두 대괄호`[]`안에 작성합니다. 예를 들어, 문단 안에 있는 모든 단어를 작성하기 위해서, 대괄호 `[]` 안에 `a`, `e`, `i`, `o`, `u` 문자들을 작성합니다..",

  "steps.negatedCharacterSet.title": "부정 문자 집합`[^abc]`",
  "steps.negatedCharacterSet.description": "아래 문단에서 'ber'와 'bo'를 제외한 모든 단어를 찾으려면 대괄호 '[]' 안에 캐럿 '^' 문자 뒤에 'e'와 'o'를 나란히 입력하세요.",

  "steps.range.title": "문자 범위`[a-z]`",
  "steps.range.description": "지정된 범위의 글자를 찾으려면 시작 글자와 끝 글자를 대괄호 '[]' 사이에 대시 '-'로 작성하세요. 이는 대소문자를 구분합니다. 'e'와 'o' 사이의 모든 소문자를 선택하는 식을 입력합니다.",

  "steps.rangeNumber.title": "숫자 범위`[0-9]`",
  "steps.rangeNumber.description": "특정 범위내의 숫자를 찾기 위해서, 시작하는 숫자와 끝 숫자가 두 숫자 사이에`-`와 함께 `[]`안에 입력됩니다. 3,6을 포함한 그 사이의 숫자를 찾는 표현을 작성해보세요."

  "examples.basicMatchers.title": "실습: 기본 매칭",
  "examples.basicMatchers.description": "문단안에 `of`와 함께 쓰이는 단어들을 선택할 표현을 작성하세요.",

  "examples.dotCharacter.title": "실습: 아무 문자",
  "examples.dotCharacter.description": "문단에서 개별 문자, 숫자, 공백 및 특수 문자를 선택하기 위한 표현식을 입력합니다. 당신이 작성한 표현법은 어떤 문자든지 매칭되어야 합니다.",

  "examples.characterSet.title": "실습: ",
  "examples.characterSet.description": "문단에 각 단어와 일치하는 문구를 쓰세요. 변경되는 문자는 오직 단어의 이니셜뿐입니다.",

  "examples.negatedCharacterSet.title": "실습: 부정 문자 집합",
  "examples.negatedCharacterSet.description": "beor와 beur 이외의 다른 표현과 일치하는 표현을 본문에 적어주세요. 부정 문자 집합을 이용하여 표현해주세요.",

  "examples.range.title": "실습: 문자 범위",
  "examples.range.description": "글에서 'g'에서 'k'까지 선택할 수 있는 표현을 쓰세요.\\n`g` 및 'k' 문자도 이 범위에 포함되어야 합니다.",

  "examples.rangeNumber.title": "실습: 숫자 범위",
  "examples.rangeNumber.description": "문단에서 '2'부터 '7'까지의 숫자를 선택하는 식을 입력합니다.\\n`2` 와 `7`또한 범위에 포함되어야 합니다.",

  "steps.repetitions.title": "반복",
  "steps.repetitions.description": "일부 특수 문자는 텍스트에서 문자가 반복되는 횟수를 지정하는 데 사용됩니다. 이러한 특수 문자들은 `+`, `*`, `?` 입니다.",

  "steps.asterisk.title": "별모양기호 `*`",
  "steps.asterisk.description": "문자가 전혀 일치하지 않거나 여러 번 일치했음을 나타내기 위해 끝에 별기호 '*'를 붙입니다. 예를 들어, 문자 'e'가 본문에서 나타나면 안됨을 의미하거나, 한 번 이상 나란히 나타남을 의미합니다.",

  "steps.plusCharacter.title": "덧셈기호 `+`",
  "steps.plusCharacter.description": "문자가 한 번 이상 발생할 수 있음을 나타내기 위해 끝에 더하기 기호 '+'를 붙입니다. 예를 들어, 문자 'e'가 본문에서 한 번 이상 나타날 수 있음을 의미합니다.",

  "steps.questionMark.title": "물음표기호 `?`",
  "steps.questionMark.description": "문자가 선택 사항임을 나타내기 위해 끝에 물음표를 붙입니다. 예를 들어, 다음 문자 'u'가 선택 사항임을 나타냅니다.",

  "steps.quantifier.title": "중괄호 - 1",
  "steps.quantifier.description": "우리는 문자의 발생 횟수를 표현하기 위해 마지막에 몇 번이 일어나길 원하는지 중괄호 '{n}'로 나타냅니다. 예를 들어, 다음 문자 'e'는 '2'번만 나타남을 의미합니다.",

  "steps.quantifierMin.title": "중괄호 - 2",
  "steps.quantifierMin.description": "최소한 문자의 발생 횟수를 표현하기 위해, 우리는 끝에는 쉼표 ''와, 안쪽에는 중괄호 '{n, }'를 붙여서 문자가 최소한 몇번 나타나는지 표현합니다. 예를 들어, 다음 문자 'e'는 '3'번이상 나타남을 의미합니다",

  "steps.quantifierRange.title": "중괄호 - 3",
  "steps.quantifierRange.description": "특정 숫자 범위에서 문자의 발생을 표현하기 위해 범위내에 중괄호 '{x,y}'를 씁니다. 예를 들어, `e`는 `1` 과 `3`사이에서만 나타날 수 있습니다.",

  "examples.asterisk.title": "실습: 별기호 `*`",
  "examples.asterisk.description": "별기호 '*'를 사용하여 문단에 문자 'e'가 없거나 두 개 이상의 단어가 있는 경우에 적합한 각 단어를 선택하는 식을 작성합니다.",

  "examples.plusCharacter.title": "실습: 덧셈기호 `+`",
  "examples.plusCharacter.description": "더하기 기호 '+'를 사용하여 문단에서 문자 'e'가 한 번 이상 나타나는 단어를 선택합니다.",

  "examples.questionMark.title": "실습: 물음표기호 `?`",
  "examples.questionMark.description": "문자 'n'이 선택 사항임을 나타내는 식을 물음표 '?'를 통해 사용하세요. 그러면 a와 an을 모두 선택할 수 있습니다.",

  "examples.quantifier.title": "실습: 중괄호 - 1",
  "examples.quantifier.description": "중괄호{}를 사용하여 문단에서 '0'부터 '9'까지의 4'자리 숫자를 선택하기 위해 식을 쓰세요.",

  "examples.quantifierMin.title": "실습: 중괄호 - 2",
  "examples.quantifierMin.description": "중괄호 '{}'을(를) 사용하여 문단에서 '2'회 이상 발생하는 숫자 '0'과 '9' 사이의 숫자를 선택하세요.",

  "examples.quantifierRange.title": "실습: 즁괄호 - 3",
  "examples.quantifierRange.description": "중괄호 '{}'를 사용하여 최소한 1에서 4 사이의 문단에서 '0'에서 '9' 사이의 숫자를 선택하세요.",

  "steps.groupping.title": "소괄호 `( )`: 그룹화",
  "steps.groupping.description": "우리는 어떤 규칙을 참조하거나 적용시키기위헤 표현을 그룹화 할 수 있습니다. 표현을 그룹화하기 위해 `()` 소괄호를 사용합니다. 아래와 같이`haa` 를 그룹화 할 수 있습니다.",

  "steps.groupReference.title": "그룹 참조",
  "steps.groupReference.description": "단어 `ha` 와 `haa`는 그룹화 되었습니다. 첫번째 그룹은 중복을 피하기 위해 `\\1`로 쓰입니다. 여기서 `1`는 그룹의 순서를 의미합니다. 표현 끝의 형식 `\\2`는 두번째 그룹을 의미합니다.",

  "steps.nonCapturingGroupping.title": "소괄호 `(?: )`: 확인되지 않는 그룹화",
  "steps.nonCapturingGroupping.description": "표현식을 그룹화하여 참조에 의해 걸리지 않도록 할 수 있습니다. 예를 들어, 아래 그룹들을 보세요. 그러나 우리가 '\\1'로 나타내는 첫 번째 그룹 참조는 사실 두 번째 그룹을 가리키는데, 첫 번째 그룹은 학습되지 않은 그룹이기 때문입니."

  "steps.pipeCharacter.title": "파이프 문자 `|`",
  "steps.pipeCharacter.description": "표현이 다른 표현 안에 있을 수 있도록 지정할 수 있습니다. 그러므로, 가능한 모든 진술은 파이프 기호 `|`로 구분되어 작성됩니다. 이것은 문자 집합 '[abc]'와 다르며 문자 집합은 문자 수준에서 작동합니다. 대안은 표현 수준에 있습니다. 예를 들어,다음 표현은 'cat'과 'cat'을 모두 선택합니다. 표현식의 끝에 파이프 기호 '|'를 하나 더 추가하고 'rat'를 입력하여 모든 단어가 선택되도록 합니다."

  "steps.escapeCharacter.title": "탈출 문자  `\\`",
  "steps.escapeCharacter.description": "There are special characters that we use when writing regex. `{ } [ ] / \\ + * . $^ | ?` Before we can select these characters themselves, we need to use an escape character `\\`. For example, to select the dot `.` and asterisk `*` characters in the text, let's add an escape character `\\` before it.",

  "steps.caret.title": "캐럿 문자 `^`:\\n라인 시작 선택",
  "steps.caret.description": "우리는 숫자를 찾기 위해 [0-9]를 사용하고 있었습니다. 의 시작 부분에 있는 숫자만 찾으려면 이 식에 '^' 기호를 붙입니다",

  "steps.dollar.title": "달러 문자 `$`:\\n라인 끝 선택",
  "steps.dollar.description": "html 값 뒤에 '$' 기호를 사용하여 줄 끝에만 있는 html 문단를 찾아봅시다.",

  "steps.wordCharacter.title": "단어 문자`\\w`: 문자, 숫자 및 밑줄",
  "steps.wordCharacter.description": "표현 `\\w` 는 문자, 숫자 및 밑줄을 찾기 위해 사용됩니다. 문단에 단어들을 찾기위해 `\\w`표현을 사용해 봅시다.",

  "steps.withoutWordCharacter.title": "단어 문자 제외 `\\W`",
  "steps.withoutWordCharacter.description": "표현 `\\W`는 문자, 숫자 및 밑줄를 제외하고 찾기 위해 사용됩니다.",

  "steps.numberCharacter.title": "숫자 문자 `\\d`",
  "steps.numberCharacter.description": "`\\d`는 숫자를 찾기 위해 사용됩니다.",

  "steps.withoutNumberCharacter.title": "숫자 문자 제외 \\D`",
  "steps.withoutNumberCharacter.description": "`\\D`는 숫자가 아닌 문자를 찾기 위해 사용됩니다.",

  "steps.spaceCharacter.title": "공백문자 `\\s`",
  "steps.spaceCharacter.description": "`\\s`는 공백문자만을 찾기 위해 사용됩니다.",

  "steps.withoutSpaceCharacter.title": "공백문자 제외 `\\S`",
  "steps.withoutSpaceCharacter.description": "`\\S` 는 공백 문자를 제외하고 찾기 위해 사용됩니다.",

  "steps.lookarounds.title": "Lookarounds",
  "steps.lookarounds.description": "우리가 쓰고 있는 구절이 다른 구절 앞이나 뒤에 오기를 원한다면, 우리는 \"lookaround\"가 필요합니다. \"lookaround\"를 사용하기 위한 다음단계로 진행하세요.",

  "steps.positiveLookahead.title": "Positive Lookahead: `(?=)`",
  "steps.positiveLookahead.description": "예를 들어, 문단에서 시간 값을 선택하려고 합니다. 그러면 그 뒤에 'PM'이 있는 숫자 값만 선택하기 위해서는 우리의 표현 뒤에 긍정적인 예측 표현 '(?=)'를 써야 합니다. 괄호 안의 '=' 기호 뒤에 'PM'을 넣으세요",

  "steps.negativeLookahead.title": "Negative Lookahead: `(?!)`",
  "steps.negativeLookahead.description": "예를 들어, 문단에서 시간 값 이외의 숫자를 선택하려고 합니다. 그러면 음의 예측식 '(?)'을 표현 뒤에 써서 뒤에 'PM'이 없는 숫자 값만 선택해야 합니다. 괄호 안쪽에 '!' 기호 뒤에 'PM'을 넣으십시오.",
  
  "steps.positiveLookbehind.title": "Positive Lookbehind: `(?<=)`",
  "steps.positiveLookbehind.description": "예를 들어, 우리는 문단에서 가격 값을 선택하기를 원합니다. 따라서 '$' 앞에 오는 숫자 값만 선택하기 위해서는 양의 뒷모습 표현 '(?)을 써야 한다.우리 표현 앞에 <=)>. 괄호 안의 '=' 기호 뒤에 '\$'를 추가합니다.",

  "steps.negativeLookbehind.title": "Negative Lookbehind: `(?&lt;!)`",
  "steps.negativeLookbehind.description": "예를 들어, 우리는 문단에서 가격 값 이외의 숫자를 선택하기를 원합니다.Therefore, '$' 앞에 없는 숫자 값만 선택하려면 표현 앞에 `(?&lt;!)` 뒤에 음의 모양을 써야 합니다. 괄호 안의 '!' 뒤에 '\$'를 추가합니다.",

  "steps.flags.title": "Flags",
  "steps.flags.description": "Flags는 표현의 결과는 바꿉니다. 이는 `modifiers`로도 불리는 이유입니다. 입력된 식이 문단을 별도의 줄로 처리할지, 대소문자를 구분할지, 모든 일치 항목을 찾을지를 결정하세요. flags을 배우기 위한 다음 단계로 진행하세요.",

  "steps.flagsGlobal.title": "global flag"
  "steps.flagsGlobal.description": "`global` flag causes the expression to select all matches. If not used it will only select the first match. Now enable the `global` flag to be able to select all matches.",

  "steps.flagsMultiline.title": "다중문자열 Flag",
  "steps.flagsMultiline.description": "RegEx는 모든것을 한 문장으로 봅니다. 하지만 우리는 각 문장을 보기위해 multiline` flag를 사용합니다. 이런 식으로 표현들은 각 줄마다 따로 적용됩니다. 이제 `multiline` flag 모든 매칭을 찾기위해 사용할수 있게 되었습니다.",

  "steps.flagsCaseInsensitive.title": "대소문자 비구분 Flag",
  "steps.flagsCaseInsensitive.description": "우리가 쓴 표현의 대/소문자를 구분하지 않으려면 대/소문자를 구분하지 않는 flag를 활성화해야 합니다.",
  
  "steps.greedyMatching.title": "greedy 매칭",
  "steps.greedyMatching.description": "RegEx 는 기본적으로 greedy 매칭이 아닙니다. 이는 매칭을 가능한만큼 한다는 것을 의미합니다. 아래 예시를 보면, 이것은 `r`로 끝나는 모든 문자와 매칭하므로 그 앞에 있는 모든 단어들이 가능하다는 뜻입니다. 그러나 이는 첫 글자 'r'로 끝나지 않습니다.",

  "steps.lazyMatching.title": "Lazy 매칭",
  "steps.lazyMatching.description": "Lazy 매칭은 greedy과 다르게 처음 매칭에서 종료합니다. 예를 들어, 아래 예시에서 문자 'r'로 끝나고 문자 뒤에 오는 첫 번째 일치를 찾으려면 '*' 뒤에 '?'를 추가하여야 합니다. 이는 매치가 `r`앞에서 멈춘다는 것을 의미합니다.",

  "steps.completeAllSteps.title": "축하합니다. 모든 단계를 완료하셨습니다.",
  "steps.completeAllSteps.description": "원할 때마다 이전 단계로 돌아갈 수 있으며, 통과한 모든 단계를 쉽게 탐색할 수 있습니다."
}

